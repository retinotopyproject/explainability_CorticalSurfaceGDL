import numpy as np
import torch
import os

from Retinotopy.functions.def_ROIs_WangParcels import roi as roi2
from Retinotopy.functions.def_ROIs_WangParcelsPlusFovea import roi
from Retinotopy.functions.plusFovea import add_fovea
from Retinotopy.functions.plusFovea import add_fovea_R
from Retinotopy.functions.error_metrics import smallest_angle

"""
This code was copied from the deepRetinotopy repository, from the file 
'ModelEval_MeanDeltaTheta_PA.py' in the Manuscript/stats/left_hemi dir
(https://github.com/Puckett-Lab/deepRetinotopy/). The file has been
modified so that it can be used for either hemisphere, depending on 
the value specified in the var 'hemisphere', and for either the HCP or NYU
dataset. References to Benson14 predictions have been removed, as they 
were not used.
This file can be run to create various 'ErrorPerParticipant' .npz files
for the PA LH/RH Test set, which are used in 
Figure7b_DeltaTheta_ModelvsAverageMap.py.

The code requires that several other files are generated first:
    - Manuscript/plots/output/{dataset_filename}MaskEccentricity_above1below8ecc_{L or R}H.npz
    (generated by running Manuscript/plots/{dataset_filename}SuppFigure3_ECCaverage_plot.py
    for the corresponding hemisphere for the Test set)
    - Manuscript/plots/output/{dataset_filename}AveragePolarAngleMap_{L or R}H.npz (generated by 
    running Manuscript/plots/{dataset_filename}SuppFigure3_PAaverage_plot.py for the 
    corresponding hemisphere for the Test set)
    - The PA Test set results for the best performing model. This can be used
    for HCP, or non-finetuned NYU models saved in Models/generalizability. 
    Copy the model '{dataset_filename}testset-intactData_PA_{L or R}H_model*.pt' to 
    Manuscript/testset_results, then rename the model to 
    '{dataset_filename}testset-pred_deepRetinotopy_PA_{L or R}H.pt'.

Note: code implementation assumes that the file is being run from the dir 
Manuscript/stats - I have modified the code to automatically set the 
working dir to this (if it isn't already).
"""
# Set the working directory to Manuscript/stats
os.chdir(os.path.dirname(os.path.realpath(__file__)))

# Total number of cortical nodes in the mesh
NUMBER_CORTICAL_NODES = int(64984)
# Number of nodes within each hemisphere
NUMBER_HEMI_NODES = int(NUMBER_CORTICAL_NODES / 2)


def PA_difference(model, hemisphere='Left', dataset='HCP'):
    """Function to determine the difference between empirical
    and predicted polar angle values for higher order visual areas, early
    visual cortex and dorsal V1-3.

    Args:
        model (str): 'deepRetinotopy' or 'average'
        hemisphere (str): For which hemisphere will files be generated?
                          ('Left' or 'Right')
        dataset (str): For which of the datasets used will files be generated?
                          ('HCP' or 'NYU')

    Output: .npz files in ./../output named:
        '{dataset_filename}ErrorPerParticipant_PA_{L or R}H_WangParcels_' + str(model) + '_1-8.npz'
        '{dataset_filename}ErrorPerParticipant_PA_{L or R}H_EarlyVisualCortex_' + str(model) +
        '_1-8.npz'
        '{dataset_filename}ErrorPerParticipant_PA_{L or R}H_dorsalV1-3_' + str(model) + '_1-8.npz'

    """
    # Create the file name components for the chosen prediction params
    hemi_filename = hemisphere[0]

    #  Set the file names and number of test set participants (based on the dataset used)
    if dataset == 'HCP':
        dataset_filename = ''
        # 10 participants in the test set
        testset_size = 10
    elif dataset == 'NYU':
        dataset_filename = dataset + '_'
        # 43 participants in the test set
        testset_size = 43
    
    visual_areas = [
        ['hV4', 'VO1', 'VO2', 'PHC1', 'PHC2', 'V3a', 'V3b', 'LO1', 'LO2',
         'TO1',
         'TO2', 'IPS0', 'IPS1', 'IPS2', 'IPS3', 'IPS4', 'IPS5', 'SPL1']]
    models = ['pred']
    eccentricity_mask = np.reshape(
        np.load(f'./../plots/output/{dataset_filename}MaskEccentricity_' +
                f'above1below8ecc_{hemi_filename}H.npz')['list'], (-1))
    # Average map
    PA_average = np.load(f'./../plots/output/{dataset_filename}AveragePolarAngleMap_' +
                        f'{hemi_filename}H.npz')['list']

    for k in range(len(visual_areas)):
        mean_delta = []
        for m in range(len(models)):
            predictions = torch.load(
                f'./../testset_results/{dataset_filename}testset-{models[m]}_deepRetinotopy_' +
                f'PA_{hemi_filename}H.pt', map_location='cpu')

            # ROI settings
            label_primary_visual_areas = ['ROI']
            final_mask_L, final_mask_R, index_L_mask, index_R_mask = roi(
                label_primary_visual_areas)
            ROI1 = np.zeros((NUMBER_HEMI_NODES, 1))
            # Apply relevant hemisphere's mask to ROI1
            if hemisphere == 'Left':
                ROI1[final_mask_L == 1] = 1
            else:
                # hemisphere == 'Right'
                ROI1[final_mask_R == 1] = 1

            # Visual areas
            final_mask_L, final_mask_R, index_L_mask, index_R_mask = roi2(
                visual_areas[k])
            primary_visual_areas = np.zeros((NUMBER_HEMI_NODES, 1))
            # Apply relevant hemisphere's mask to primary visual areas
            if hemisphere == 'Left':
                primary_visual_areas[final_mask_L == 1] = 1
            else:
                # hemisphere == 'Right'
                primary_visual_areas[final_mask_R == 1] = 1

            # Final mask
            mask = ROI1 + primary_visual_areas
            mask = mask[ROI1 == 1]

            theta_withinsubj = []
            for j in range(len(predictions['Predicted_values'])):
                for i in range(len(predictions['Predicted_values'])):
                    if i == j:
                        # Loading predicted values
                        # Polar angles
                        if model == 'deepRetinotopy':
                            pred = np.reshape(
                                np.array(predictions['Predicted_values'][i]),
                                (-1, 1))
                        if model == 'average':
                            pred = np.reshape(np.array(PA_average), (-1, 1))
                        measured = np.reshape(
                            np.array(predictions['Measured_values'][j]),
                            (-1, 1))

                        # Rescaling
                        minus = pred > 180
                        sum = pred < 180
                        pred[minus] = pred[minus] - 180
                        pred[sum] = pred[sum] + 180
                        pred = np.array(pred) * (np.pi / 180)

                        minus = measured > 180
                        sum = measured < 180
                        measured[minus] = measured[minus] - 180
                        measured[sum] = measured[sum] + 180
                        measured = np.array(measured) * (np.pi / 180)

                        # Computing delta theta
                        theta = smallest_angle(pred[eccentricity_mask],
                                               measured[eccentricity_mask])
                        theta_withinsubj.append(
                            theta[mask[eccentricity_mask] > 1])
            mean_theta_withinsubj = np.mean(np.array(theta_withinsubj), axis=1)
            mean_delta.append(mean_theta_withinsubj)
        mean_delta = np.reshape(np.array(mean_delta), (1, -1))

    np.savez(f'./output/{dataset_filename}ErrorPerParticipant_PA_{hemi_filename}H_' +
             f'WangParcels_{str(model)}_1-8.npz',
             list=np.reshape(theta_withinsubj, (testset_size, -1)))

    # Early visual cortex
    label_primary_visual_areas = ['V1d', 'V1v', 'fovea_V1', 'V2d', 'V2v',
                                  'fovea_V2', 'V3d', 'V3v', 'fovea_V3']
    # Add fovea to the relevant hemisphere's V1, V2, V3 parcels
    if hemisphere == 'Left':
        V1, V2, V3 = add_fovea(label_primary_visual_areas)
    else:
        # hemisphere == 'Right'
        V1, V2, V3 = add_fovea_R(label_primary_visual_areas)
    primary_visual_areas = np.sum(
        [np.reshape(V1, (-1, 1)), np.reshape(V2, (-1, 1)),
         np.reshape(V3, (-1, 1))], axis=0)

    mean_delta_2 = []
    for m in range(len(models)):
        predictions = torch.load(
            f'./../testset_results/{dataset_filename}testset-{models[m]}_deepRetinotopy_' +
            f'PA_{hemi_filename}H.pt', map_location='cpu')

        # ROI settings
        label_primary_visual_areas = ['ROI']
        final_mask_L, final_mask_R, index_L_mask, index_R_mask = roi(
            label_primary_visual_areas)
        ROI1 = np.zeros((NUMBER_HEMI_NODES, 1))
        # Apply relevant hemisphere's mask to ROI1
        if hemisphere == 'Left':
            ROI1[final_mask_L == 1] = 1
        else:
            # hemisphere == 'Right'
            ROI1[final_mask_R == 1] = 1

        mask = ROI1 + np.reshape(primary_visual_areas, (NUMBER_HEMI_NODES, 1))
        mask = mask[ROI1 == 1]

        theta_withinsubj = []
        for j in range(len(predictions['Predicted_values'])):
            for i in range(len(predictions['Predicted_values'])):
                if i == j:
                    # Polar angle
                    if model == 'deepRetinotopy':
                        pred = np.reshape(
                            np.array(predictions['Predicted_values'][i]),
                            (-1, 1))
                    if model == 'average':
                        pred = np.reshape(np.array(PA_average), (-1, 1))
                    measured = np.reshape(
                        np.array(predictions['Measured_values'][j]),
                        (-1, 1))

                    # Rescaling
                    minus = pred > 180
                    sum = pred < 180
                    pred[minus] = pred[minus] - 180
                    pred[sum] = pred[sum] + 180
                    pred = np.array(pred) * (np.pi / 180)

                    minus = measured > 180
                    sum = measured < 180
                    measured[minus] = measured[minus] - 180
                    measured[sum] = measured[sum] + 180
                    measured = np.array(measured) * (np.pi / 180)

                    # Computing delta theta
                    theta = smallest_angle(pred[eccentricity_mask],
                                           measured[eccentricity_mask])
                    theta_withinsubj.append(theta[mask[eccentricity_mask] > 1])
        mean_theta_withinsubj = np.mean(np.array(theta_withinsubj), axis=1)
        mean_delta_2.append(mean_theta_withinsubj)
    mean_delta_2 = np.reshape(np.array(mean_delta_2), (1, -1))

    np.savez(f'./output/{dataset_filename}ErrorPerParticipant_PA_{hemi_filename}H_' +
            f'EarlyVisualCortex_{str(model)}_1-8.npz', 
            list=np.reshape(theta_withinsubj, (testset_size, -1)))

    # Dorsal early visual cortex
    visual_areas = [
        ['V1d', 'V2d', 'V3d']]
    for k in range(len(visual_areas)):
        mean_delta = []
        for m in range(len(models)):
            predictions = torch.load(
                f'./../testset_results/{dataset_filename}testset-{models[m]}_deepRetinotopy_' +
                f'PA_{hemi_filename}H.pt', map_location='cpu')

            # ROI settings
            label_primary_visual_areas = ['ROI']
            final_mask_L, final_mask_R, index_L_mask, index_R_mask = roi(
                label_primary_visual_areas)
            ROI1 = np.zeros((NUMBER_HEMI_NODES, 1))
            # Apply relevant hemisphere's mask to ROI1
            if hemisphere == 'Left':
                ROI1[final_mask_L == 1] = 1
            else:
                # hemisphere == 'Right'
                ROI1[final_mask_R == 1] = 1

            # Visual areas
            final_mask_L, final_mask_R, index_L_mask, index_R_mask = roi2(
                visual_areas[k])
            primary_visual_areas = np.zeros((NUMBER_HEMI_NODES, 1))
            # Apply relevant hemisphere's mask to primary visual areas
            if hemisphere == 'Left':
                primary_visual_areas[final_mask_L == 1] = 1
            else:
                # hemisphere == 'Right'
                primary_visual_areas[final_mask_R == 1] = 1

            # Final mask
            mask = ROI1 + primary_visual_areas
            mask = mask[ROI1 == 1]

            theta_withinsubj = []
            for j in range(len(predictions['Predicted_values'])):
                for i in range(len(predictions['Predicted_values'])):

                    if i == j:
                        # Polar angle
                        if model == 'deepRetinotopy':
                            pred = np.reshape(
                                np.array(predictions['Predicted_values'][i]),
                                (-1, 1))
                        if model == 'average':
                            pred = np.reshape(np.array(PA_average), (-1, 1))
                        measured = np.reshape(
                            np.array(predictions['Measured_values'][j]),
                            (-1, 1))

                        # Rescaling
                        minus = pred > 180
                        sum = pred < 180
                        pred[minus] = pred[minus] - 180
                        pred[sum] = pred[sum] + 180
                        pred = np.array(pred) * (np.pi / 180)

                        minus = measured > 180
                        sum = measured < 180
                        measured[minus] = measured[minus] - 180
                        measured[sum] = measured[sum] + 180
                        measured = np.array(measured) * (np.pi / 180)

                        # Computing delta theta
                        theta = smallest_angle(pred[eccentricity_mask],
                                               measured[eccentricity_mask])
                        theta_withinsubj.append(
                            theta[mask[eccentricity_mask] > 1])

            mean_theta_withinsubj = np.mean(np.array(theta_withinsubj), axis=1)
            mean_delta.append(mean_theta_withinsubj)
        mean_delta = np.reshape(np.array(mean_delta), (1, -1))

    np.savez(f'./output/{dataset_filename}ErrorPerParticipant_PA_{hemi_filename}H_' +
            f'dorsalV1-3_{str(model)}_1-8.npz', 
            list=np.reshape(theta_withinsubj, (testset_size, -1)))


# Create an output folder if it doesn't already exist
directory = './output'
if not os.path.exists(directory):
    os.makedirs(directory)

PA_difference('average', 'Left', 'HCP')
PA_difference('deepRetinotopy', 'Left', 'HCP')
# PA_difference('average', 'Right', 'HCP')
# PA_difference('deepRetinotopy', 'Right', 'HCP')
# PA_difference('average', 'Left', 'NYU')
# PA_difference('deepRetinotopy', 'Left', 'NYU')
# PA_difference('average', 'Right', 'NYU')
# PA_difference('deepRetinotopy', 'Right', 'NYU')

